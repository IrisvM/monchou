# Code Conventions for Monchou Project

This document outlines the code conventions and best practices for the Monchou recipe application. All AI agents and developers should follow these guidelines when writing code for this project.

## Project Overview

- **Framework**: Next.js 15+ (App Router)
- **Runtime**: Bun
- **Language**: TypeScript with strict mode
- **UI Framework**: React 19+
- **Styling**: Tailwind CSS 4+
- **State Management**: React Context API
- **Data Format**: Markdown files with frontmatter

## TypeScript Configuration

### Strict Type Checking

- Always use TypeScript strict mode
- Explicit return types are **required** for all functions except:
  - Next.js special functions: `Page`, `generateMetadata`, `Layout`
- Use explicit type annotations for function parameters
- Return type should be `ReactNode` for React components

### Path Aliases

Use configured path aliases for imports:

```typescript
@/helpers/*     // ./helpers/*
@/components/*  // ./components/*
@/hooks/*       // ./hooks/*
@/api/*         // ./api/*
```

### Example

```typescript
// ✅ Correct
export default function Header({ children }: Props): ReactNode {
  return <header>{children}</header>;
}

// ❌ Incorrect - missing return type
export default function Header({ children }: Props) {
  return <header>{children}</header>;
}
```

## File Structure & Organization

### Component Structure

Each component should have its own directory with:

- `ComponentName.tsx` - Main component file
- `index.ts` - Re-export for clean imports
- Additional related files (e.g., `ComponentName.loading.tsx`)

```
ComponentName/
  ├── ComponentName.tsx
  ├── index.ts
  └── ComponentName.loading.tsx (if needed)
```

### Index Files

Always create barrel exports in `index.ts`:

```typescript
import ComponentName from './ComponentName';

export default ComponentName;
```

## Component Conventions

### Naming

- Use **PascalCase** for component names and files
- Use **camelCase** for variables, functions, and props
- Use **kebab-case** for file slugs and routes

### Component Definition

- **Always** use `export default function` for components (not arrow functions)
- Define props as a separate `type`
- Explicitly type the return value as `ReactNode`
- Use destructuring for props

```typescript
// ✅ Correct
type Props = {
  title: string;
  className?: string;
};

export default function MyComponent({ title, className }: Props): ReactNode {
  return <div className={className}>{title}</div>;
}

// ✅ Also acceptable for simple props
export default function MyComponent({
  recipe
}: {
  recipe: Recipe
}): ReactNode {
  return <div>{recipe.title}</div>;
}
```

### Client vs Server Components

- Components are server components by default
- Add `'use client'` directive at the top of file for client components
- Use client components when:
  - Using hooks (`useState`, `useEffect`, `useContext`, etc.)
  - Handling browser events
  - Using browser APIs

```typescript
'use client';

import { useState } from 'react';
// ... rest of component
```

### React Hooks

- Use the `use()` hook for accessing Context in client components
- Prefer `useCallback` for memoizing functions passed as props
- Use `useState` for local component state

```typescript
// ✅ Correct - using use() for context
const { has, add, remove, isLoaded } = use(SelectionContext);
```

## Styling Conventions

### Tailwind CSS

- Use Tailwind utility classes for all styling
- Build class strings using arrays with `.filter()` and `.join()` for conditional classes
- Use the `classNames` helper for combining classes

```typescript
// ✅ Correct - using array, filter, and join
className={[
  'absolute right-4 top-4 w-10 h-10',
  'bg-fuchsia-100 text-gray-400',
  'hover:text-fuchsia-50 focus:text-fuchsia-50',
  isSelected ? 'ring-2 ring-fuchsia-200' : '',
]
  .filter((a) => !!a)
  .join(' ')}

// ✅ Using classNames helper
import classNames from '@/helpers/classNames';

className={classNames(
  'base-class',
  isActive ? 'active-class' : undefined
)}
```

### Color Palette

Primary colors: `fuchsia-*` palette for interactive elements

## ESLint & Code Quality

### Required Rules

- **No unused variables**: Variables starting with `_` are ignored
- **No unused imports**: Auto-removed by `unused-imports` plugin
- **Unix line endings**: Always use LF (`\n`), not CRLF
- **React JSX Pascal Case**: Component names must be PascalCase
- **Button types**: Always specify `type` attribute on buttons
- **Explicit return types**: Required for all functions (except whitelisted Next.js functions)

### Code Formatting

- Use **Prettier** for code formatting
- Run `bun run fix` to auto-fix linting and formatting issues
- Pre-commit hooks automatically format staged files

## Next.js Conventions

### App Router

- Use the App Router (not Pages Router)
- File-based routing in `app/` directory
- Server components by default

### Special Files & Functions

- `layout.tsx` - Shared layout wrapper
- `page.tsx` - Route page component
- `route.ts` - API route handler
- `loading.tsx` - Loading UI
- `error.tsx` - Error UI

### Async Components & Props

Server components can be async. Next.js 15+ requires `params` and `searchParams` to be awaited:

```typescript
// ✅ Correct - await params
export default async function RecipesByTag(props: {
  params: Promise<{ type: string }>;
}): Promise<ReactNode> {
  const { type } = await props.params;
  // ... rest of component
}
```

### Metadata

- Use Next.js `Metadata` type for page metadata
- Export as `metadata` constant

```typescript
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Page Title',
  description: 'Page description',
};
```

## API & Data Conventions

### Type Definitions

- Define types for all data structures
- Use meaningful names that describe the data
- Co-locate types with related functions

```typescript
export type Recipe = RecipeListItem & {
  ingredients: { quantity: number; unit: string; title: string; to?: string }[];
  serving: string;
  content: string;
};

export type RecipeListItem = {
  title: string;
  tags: string[];
  type: string;
  slug: string;
  image: null | string;
  filename: string;
  key: string;
};
```

### Error Handling

- Use custom error classes (e.g., `NotFoundError`)
- Throw errors with descriptive messages

```typescript
if (!recipe) {
  throw new NotFoundError(`Recipe not found for type=${type} slug=${slug}`);
}
```

## General Best Practices

### Imports

- Group imports logically (external packages, then local modules)
- Use path aliases for cleaner imports
- Import `ReactNode` from React for typing

```typescript
import { ReactNode } from 'react';
import { SelectionContext } from '../../context/selectionContext';
import RecipeMeta from '@/components/RecipeMeta';
import RecipeImage from '@/components/RecipeImage';
```

### Props

- Use `PropsWithChildren` for components that accept children
- Make optional props explicit with `?`
- Provide sensible defaults using destructuring

```typescript
type Props = {
  href: string;
  className?: string;
  exact?: boolean;
};

export default function Link({
  href,
  className,
  exact = false,
}: PropsWithChildren<Props>): ReactNode {
  // ...
}
```

### Accessibility

- Use semantic HTML elements
- Include ARIA attributes when appropriate (`role`, `aria-selected`, `aria-current`, etc.)
- Ensure keyboard navigation works

```typescript
<button
  role="checkbox"
  aria-selected={isSelected}
  type="button"
  // ...
>
```

### Language

- UI text is in **Dutch** (nl)
- Code comments and documentation are in **English**
- HTML lang attribute: `lang="nl"`

## Development Workflow

### Commands

- `bun run dev` - Start development server with Turbopack
- `bun run build` - Build for production (runs index builder first)
- `bun run lint` - Check linting and formatting
- `bun run fix` - Auto-fix linting and formatting issues

### Pre-commit Hooks

- Automatically applied via `dev/apply-git-hooks`
- Runs ESLint and Prettier on staged files
- Formats `.js`, `.tsx`, `.ts`, `.json`, `.md` files

## Testing & Validation

- Always run `bun run lint` before committing
- Test components in isolation when possible
- Verify TypeScript compilation with no errors
- Check that all imports resolve correctly

## Common Patterns

### Context Usage

```typescript
'use client';

import { use } from 'react';
import { SelectionContext } from '@/context/selectionContext';

export default function MyComponent(): ReactNode {
  const { selectedRecipes, add, remove } = use(SelectionContext);
  // ...
}
```

### Conditional Rendering

```typescript
{isLoaded && (
  <button type="button" onClick={handleClick}>
    Click me
  </button>
)}
```

### Lists

```typescript
<ul>
  {items.map((item) => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
```

---

**Remember**: Consistency is key. Follow these conventions to maintain a clean, maintainable codebase.
